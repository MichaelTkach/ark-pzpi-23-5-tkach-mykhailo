МІНІСТЕРСТВО НАУКИ І ОСВІТИ УКРАЇНИ

ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ


ЗВІТ
До практичного завдання №2
з дисципліни «Аналіз та рефакторинг коду»


Виконав:                                                                          Перевірив:
ст. гр. ПЗПІ-23-5                        				ст. викладач кафедри ПІ
Ткач Михайло                              Сокорчук Ігор Петрович










Харків 2025
     1 ІСТОРІЯ ЗМІН

№Дата Версія звіту Опис змін та виправлень 
1 10.12.2025 0.1 Створено розділи 2, 3.1, 3.2 
2 11.12.2025 0.2 Створено розділи 3.3, Висновки
     2 ЗАВДАННЯ
     
     Обрати три методи рефакторингу та адаптувати їх приклади для мови C++.
     
     3 ОПИС ВИКОНАНОЇ РОБОТИ
     
     У рамках цієї роботи було обрано три методи рефакторингу коду:
     1. Separate Domain from Presentation — відокремлення бізнес-логіки
     2. Replace Inheritance with Delegation — заміна спадкування на композицію
     3. Push Down Method — переміщення методів до дочірніх класів
     
     3.1 Separate domain from presentation
     
     Метод Separate Domain from Presentation відокремлює доменну логіку від UI. У C++ це часто реалізується через патерн MVC або просто розділенням класів.
     
     В додатку В.1 наведено код, де логіка змішана з `std::cout` (консольний UI).
     В додатку В.2 логіка винесена в клас `Order`, а введення-виведення — в `ConsoleView`.
     
     Переваги:
     * Можливість замінити консоль на GUI (Qt, WinAPI) без змін `Order`.
     * Легше тестувати `Order` (Unit-тести без вводу користувача).
     
     3.2 Replace inheritance with delegation
     
     У C++ спадкування є сильним зв'язком. Якщо `Manager` та `Developer` наслідують `Employee` тільки для перевикористання коду зарплати, це призводить до проблем.
     
     В додатку В.3 використовується спадкування.
     В додатку В.4 `Employee` містить вказівник на інтерфейс `IRole` (Делегування).
     
     Переваги:
     * Можна змінювати роль у Run-time (Strategy pattern).
     * Менша зв'язаність класів.
     
     3.3 Push down method
     
     Якщо метод у базовому класі використовується лише одним нащадком, його слід спустити вниз.
     
     В додатку В.5 базовий клас `Shape` має метод `get_radius()`, який має сенс тільки для `Circle`, але доступний і `Rectangle`. Це порушує Interface Segregation.
     В додатку В.6 метод переміщено в `Circle`.
     
     Переваги:
     * Чистіший інтерфейс базового класу.
     * Відсутність "сміттєвих" методів у нащадків.

     ВИСНОВКИ
     
     Рефакторинг у C++ дозволяє керувати складністю, покращувати час компіляції (через розділення залежностей) та робити код безпечнішим.
     
     ВИКОРИСТАНІ ДЖЕРЕЛА
     1. Martin, Robert C. Clean Code.
     2. Refactoring Guru.
     

ДОДАТОК А
Посилання на відео (Аналогічно Pract 1, адаптовано під C++)

ДОДАТОК В
Програмний код (C++)

     В.1 Код для методу Separate Domain from Presentation (ДО)
      1 class OrderApp {
      2 public:
      3     void AddItem(std::string name, double price) {
      4         // Логіка + UI
      5         items.push_back({name, price});
      6         std::cout << "Added: " << name << " Price: " << price << std::endl;
      7     }
      8 };

     В.2 Код для методу Separate Domain from Presentation (ПІСЛЯ)
      1 class Order { // Тільки логіка
      2     std::vector<Item> items;
      3 public:
      4     void Add(Item item) { items.push_back(item); }
      5     double Total() const { ... }
      6 };
      7 
      8 class OrderView { // Тільки UI
      9     Order& order;
      10 public:
      11    void PrintOrder() { ... }
      12 };

     В.3 Код для методу Replace Inheritance with Delegation (ДО)
      1 class Employee {
      2     virtual double Bonus() { return salary * 0.1; }
      3 };
      4 class Manager : public Employee { ... }; // Жорстке спадкування

     В.4 Код для методу Replace Inheritance with Delegation (ПІСЛЯ)
      1 struct IRole {
      2     virtual double CalcBonus(double salary) = 0;
      3 };
      4 class Employee {
      5     std::unique_ptr<IRole> role_; // Делегування
      6 public:
      7     double Bonus() { return role_->CalcBonus(salary_); }
      8 };

     В.5 Код для методу Push Down Method (ДО)
      1 class Shape {
      2 public:
      3     virtual double GetArea() = 0;
      4     double GetRadius() { return 0; } // Зайвий метод для Rectangle
      5 };
      6 class Rectangle : public Shape { ... }; // Має GetRadius(), що дивно

     В.6 Код для методу Push Down Method (ПІСЛЯ)
      1 class Shape {
      2 public:
      3     virtual double GetArea() = 0;
      4 };
      5 class Circle : public Shape {
      6 public:
      7     double GetRadius() { return radius_; } // Метод там, де треба
      8 };
