МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

Факультет Комп’ютерних наук
Кафедра Програмної інженерії

ЗВІТ
до практичного завдання №1
з дисципліни «Аналіз та рефакторинг програмного коду»
на тему: «Правила оформлення програмного коду мовою C++»

Виконав:
ст. гр. ПЗПІ-23-5
Ткач Михайло

Перевірив:
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович

Харків 2025

1. МЕТА РОБОТИ

     Метою даної роботи є формування глибокого розуміння важливості дотримання стандартів оформлення програмного коду (Code Convention) при розробці складних програмних систем мовою C++. Освоєння рекомендацій щодо стилю кодування, найменування змінних, структурування проектів та документування дозволяє створювати якісне, надійне та легке у підтримці програмне забезпечення. Також метою є вивчення сучасних інструментів статичного аналізу, тестування (Google Test) та автоматичної генерації документації (Doxygen), що є невід’ємною частиною професійної діяльності інженера-програміста.

2. ХІД РОБОТИ

     2.1 Стильові рекомендації

     Ефективність та читабельність коду є критичними факторами успіху будь-якого проекту. Мова C++ надає розробнику значну гнучкість, що без чітких правил може призвести до створення заплутаного коду. Тому великі технологічні компанії та спільноти розробників створюють стандарти кодування, такі як C++ Core Guidelines (розроблений Б’ярном Страуструпом) або Google C++ Style Guide.

     Форматування коду:
     * Відступи: Рекомендується використовувати 4 пробіли для позначення вкладеності блоків коду. Табуляція може відображатися по-різному в різних редакторах, тому пробіли є кращим варіантом.
     * Довжина рядка: Обмеження довжини рядка (зазвичай 80, 100 або 120 символів) дозволяє комфортно переглядати код на різних пристроях та в режимі розділеного екрану IDE.
     * Фігурні дужки: Існує кілька стилів розстановки дужок. Найпоширенішим є стиль K&R (Kernighan & Ritchie) або Stroustrup Style, де відкриваюча дужка функції розміщується на наступному рядку, а дужка керуючих конструкцій (if, while) — на тому ж рядку.

     Приклад правильного форматування (див. рис. 2.1):

     // Рисунок 2.1 - Приклад форматування коду C++
     bool CheckAccess(bool is_active, int level) {
         if (is_active && level >= 3) {
             return true;
         }
         return false;
     }

     2.2 Правила найменування змінних, функцій та класів

     Правильне іменування є основою самодокументованого коду. У C++ використовуються різні конвенції залежно від типу сутності:

     * Класи та Структури (Types): Використовується стиль PascalCase, де кожне слово починається з великої літери. Назви повинні бути іменниками. (Наприклад: UserManager, HttpRequester).
     * Змінні (Variables): Локальні змінні та параметри функцій зазвичай іменуються в стилі snake_case (малими літерами через підкреслення). Це дозволяє візуально відрізняти їх від типів. (Наприклад: current_user, buffer_size).
     * Члени класу (Member Variables): Приватні поля класу часто мають суфікс "_" (Google Style), щоб відрізняти їх від локальних змінних та параметрів. (Наприклад: user_name_, connection_timeout_).
     * Функції та Методи: Використовується PascalCase (CalculateTotal) або camelCase (getUserName). Важливо дотримуватися одного стилю в межах проекту.
     * Константи: Використовується стиль kCamelCase (kMaxRetries) або традиційний UPPER_SNAKE_CASE (MAX_BUFFER_SIZE).

     Приклад оголошення класу з правилами найменування (див. рис. 2.2):

     // Рисунок 2.2 - Приклад іменування класу і методів
     class DatabaseConnection {
     public:
         void ConnectToHost(const std::string& host_name);
     private:
         std::string host_address_;
         int port_number_;
     };

     2.3 Структура коду та файлів

     Проекти на C++ зазвичай поділяються на заголовні файли (.h або .hpp) та файли реалізації (.cpp). Це дозволяє відокремити інтерфейс (API) від реалізації, що прискорює компіляцію та дозволяє приховувати деталі реалізації.

     * Заголовні файли: Містять оголошення класів, структур, прототипи функцій, шаблони (templates) та макроси. Обов’язковим є використання захисту від повторного включення (#pragma once або Header Guards #ifndef ... #define).
     * Файли реалізації: Містять визначення методів та функцій.
     * Порядок членів класу: Зазвичай спочатку йдуть public методи (інтерфейс), потім protected, і в кінці private поля та методи. Це дозволяє користувачу класу одразу бачити доступний інтерфейс.

     2.4 Принципи рефакторингу

     Рефакторинг — це процес зміни внутрішньої структури коду без зміни його зовнішньої поведінки. Одним з найпоширеніших методів є Extract Method (Виділення методу). Якщо функція стає занадто довгою або виконує кілька різних дій, частину коду слід винести в окрему функцію з зрозумілою назвою.

     Приклад до рефакторингу (див. рис. 2.3):

     // Рисунок 2.3 - Код до рефакторингу
     void ProcessUserData(User& user) {
         if (user.GetAge() > 18 && user.IsActive()) {
             double tax = user.GetSalary() * 0.2;
             user.SetBalance(user.GetBalance() - tax);
             Log("Tax deducted: " + std::to_string(tax));
         }
     }

     Приклад після рефакторингу (див. рис. 2.4):

     // Рисунок 2.4 - Код після рефакторингу (Extract Method)
     void ProcessUserData(User& user) {
         if (CanApplyTax(user)) {
             ApplyTax(user);
         }
     }
     
     bool CanApplyTax(const User& user) {
        return user.GetAge() > 18 && user.IsActive();
     }

     2.5 Оптимізація продуктивності

     C++ надає розробнику повний контроль над використанням ресурсів. Основні методи оптимізації:

     * Передача за посиланням (Pass by Reference): Складні об’єкти (рядки, вектори, власні класи) слід передавати у функції за константним посиланням (const Type&), щоб уникнути дорогого копіювання даних.
     * Керування пам’яттю (RAII): Використання Resource Acquisition Is Initialization гарантує звільнення ресурсів. Замість ручного new/delete слід використовувати розумні вказівники: std::unique_ptr (унікальне володіння) та std::shared_ptr (спільне володіння).
     * Move-семантика: Використання std::move дозволяє "переміщати" ресурси замість їх копіювання, що значно підвищує продуктивність при роботі з тимчасовими об’єктами.

     2.6 Обробка помилок

     У сучасному C++ рекомендується використовувати механізм винятків (Exceptions) для повідомлення про помилки, які не можна ігнорувати. Це дозволяє відокремити код обробки помилок від основної логіки.

     Приклад використання try-catch (див. рис. 2.5):

     // Рисунок 2.5 - Обробка винятків
     try {
         Database db;
         db.Connect("localhost");
     } catch (const std::exception& e) {
         std::cerr << "Database error: " << e.what() << std::endl;
     }

     2.7 Дотримання парадигм програмування

     C++ є мультипарадигменною мовою, що підтримує:
     * Об’єктно-орієнтоване програмування (ООП): Інкапсуляція, спадкування, поліморфізм. Дозволяє будувати складні системи через взаємодію об’єктів.
     * Узагальнене програмування (Generic Programming): Використання шаблонів (templates) дозволяє писати алгоритми, що працюють з будь-якими типами даних (наприклад, алгоритми STL: sort, find, transform).
     * Функціональне програмування: Використання лямбда-виразів та функторів.

     2.8 Тестування та документування коду

     Для забезпечення якості коду використовується модульне тестування (Unit Testing). Найпопулярнішим фреймворком для C++ є Google Test (GTest). Він дозволяє писати автоматичні перевірки окремих функцій та класів.

     Документування коду здійснюється за допомогою системи Doxygen. Спеціальні коментарі у коді дозволяють автоматично генерувати HTML-документацію з описом класів, методів та параметрів.

     Приклад документації Doxygen (див. рис. 2.6):

     // Рисунок 2.6 - Документація Doxygen
     /**
      * @brief Calculates the sum of two integers.
      * @param a The first integer.
      * @param b The second integer.
      * @return The sum of a and b.
      */
     int Sum(int a, int b);

ВИСНОВКИ

     У ході виконання практичної роботи було проведено детальний аналіз правил оформлення програмного коду мовою C++. Встановлено, що дотримання єдиного стилю (Code Style), правильне іменування змінних, використання принципів чистої архітектури та рефакторингу є критично важливими для створення якісного програмного продукту. 
     Особливу увагу було приділено специфічним для C++ аспектам: керуванню пам’яттю через RAII та розумні вказівники, оптимізації передачі даних за посиланням та використанню move-семантики. Засвоєння цих принципів дозволяє писати не лише зрозумілий, але й високопродуктивний та безпечний код.
     Також було розглянуто важливість автоматизованого тестування (Google Test) та документування (Doxygen) як невід’ємних складових процесу професійної розробки ПЗ.

ВИКОРИСТАНІ ДЖЕРЕЛА
1. Stroustrup, B. (2013). The C++ Programming Language (4th Edition). Addison-Wesley.
2. Google C++ Style Guide. [Електронний ресурс]. – Режим доступу: https://google.github.io/styleguide/cppguide.html.
3. C++ Core Guidelines. [Електронний ресурс]. – Режим доступу: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines.
4. Martin, R. C. (2008). Clean Code: A Handbook of Agile Software Craftsmanship. Prentice Hall.

ДОДАТОК А
Посилання на відео
     Відеозапис виконання роботи та демонстрація основних принципів доступні за посиланням:
     https://youtu.be/aGfTwVpqblc
     
     Таймкоди:
     00:00 Вступ. Важливість Code Convention.
     00:28 Огляд стильових рекомендацій (Google Style).
     01:08 Правила іменування змінних у C++.
     02:26 Структура проекту: Header та Source файли.
     03:15 Концепція RAII та Smart Pointers.
     04:03 Оптимізація: const reference та move-семантика.
     05:40 Обробка помилок та винятків.
     06:58 Парадигми C++: ООП та Templates.
     07:50 Unit-тестування з Google Test.
     08:30 Генерація документації Doxygen.
     09:25 Висновки.

ДОДАТОК Б
Слайди презентації

     Рисунок Б.1 – Титульний слайд презентації
     Рисунок Б.2 – Слайд: Чому важливий чистий код?
     Рисунок Б.3 – Слайд: Основні стильові правила
     Рисунок Б.4 – Слайд: Правила найменування (Naming Conventions)
     Рисунок Б.5 – Слайд: Структура C++ файлів
     Рисунок Б.6 – Слайд: Рефакторинг та оптимізація
     Рисунок Б.7 – Слайд: Керування пам’яттю (Smart Pointers)
     Рисунок Б.8 – Слайд: Тестування та документація
     Рисунок Б.9 – Висновки
